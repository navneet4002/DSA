+<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree and Search Tree Operations</title>
    <style>
        /* General reset */
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background-color: #1c1c1e;
    color: #d1d1d6;
    line-height: 1.6;
    padding: 20px;
}

.container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}

.main-content {
    flex-grow: 1;
    padding: 20px;
}

.box-main {
    max-width: 800px;
    width: 100%;
    background-color: #2c2c2e;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    border: 2px solid #3f3f42;
}

h1 {
    color: white;
    margin-bottom: 20px;
    text-align: center;
}

.firsthalf2 ul {
    list-style: none;
    padding:0;
}

.firsthalf2 li {
    margin:10px 0;
}

.firsthalf2 a {
    text-decoration: none;
    font-size: 18px;
    color: white;
    transition: color 0.3s ease;
}

.firsthalf2 a:hover {
    color: #6a6aff;
}

h2 {
    color: white;
    margin-top: 20px;
    border-bottom: 2px solid #3f3f42;
    padding-bottom: 5px;
    font-size: 26px;
}

.vasu {
    color: #d1d1d6;
    max-width: 1000px;
    font-size: large;
    width: auto;
    background-color: #2c2c2e;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    margin-top: 10px;
}

.vasu pre {
    word-wrap: break-word;
    white-space: pre-wrap;
    max-width: 100%;
    overflow-x: auto;
    background-color: #3a3a3c;
    border-radius: 4px;
    padding: 10px;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
    margin-bottom: 20px;
    border: 1px solid #5a5a5f;
    color: #f4f4f5;
}

.back-to-top {
    position: fixed;
    bottom: 20px;
    right: 10px;
    background-color: #6a6aff;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 15px;
    cursor: pointer;
    display: none;
    z-index: 1000;
    transition: background-color 0.3s ease;
}

.back-to-top:hover {
    background-color: #4f4fcc;
}

@media (max-width: 600px) {
    .box-main {
        padding: 20px;
    }

    .firsthalf2 a {
        font-size: 16px;
    }

    .back-to-top {
        font-size: 14px;
        padding: 8px 12px;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Content -->
        <section class="main-content">
            <div class="box-main">
                <h1>BINARY TREE AND SEARCH TREE OPERATIONS</h1>
                <div class="firsthalf2">
                    <ul>
                        <li><a href="#tr1">1. Construct binary tree from preorder and inorder traversal.</a></li>
                        <li><a href="#tr2">2. Binary tree level order traversal.</a></li>
                        <li><a href="#tr3">3. Print left view of binary tree.</a></li>
                        <li><a href="#tr4">4. Display the right view of binary tree.</a></li>
                        <li><a href="#tr5">5. Construct binary tree from postorder and inorder traversal.</a></li>
                        <li><a href="#tr6">6. Find the maximum depth of binary tree.</a></li>
                        <li><a href="#tr7">7. Create binary search tree using arrays (insert, delete, search, preorder, inorder, postorder, minimum element).</a></li>
                        <li><a href="#tr8">8. Create binary search tree dynamically (insert, delete, search, preorder, inorder, postorder, minimum element).</a></li>
                        <li><a href="#tr9">9. Find inorder predecessor and inorder successor of binary search tree (dynamically represented).</a></li>
                        <li><a href="#tr10">10. Check whether binary search tree contains dead end.</a></li>
                        <li><a href="#tr11">11. Create binary tree to binary search tree through array.</a></li>
                        <li><a href="#tr12">12. Find kth largest element in binary search tree through array.</a></li>
                        <li><a href="#tr13">13. Find kth smallest element in a binary search tree through array.</a></li>
                        <li><a href="#tr14">14. Print preorder traversal to postorder traversal of binary search tree.</a></li>
                        <li><a href="#tr15">15. Construct binary search tree from given preorder traversal through arrays.</a></li>
                        <li><a href="#tr16">16. Construct binary search tree from given postorder traversal through arrays.</a></li>
                        <li><a href="#tr17">17. Create strictly binary tree from the given input by the user (dynamically).</a></li>
                        <li><a href="#tr18">18. Create almost complete binary tree from the given input by the user (dynamically).</a></li>
                        <li><a href="#tr19">19. Create complete binary tree from the given input by the user (dynamically).</a></li>
                        <li><a href="#tr20">20. Count the number of nodes in binary search tree constructed dynamically.</a></li>
                    </ul>
                </div>
                
    <!-- Question 1 -->
    <h2 id="tr1">Question 1: Construct Binary Tree from Preorder and Inorder Traversal</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct Node {
            char data;
            struct Node* left;
            struct Node* right;
        };
        
        int search(char inorder[], int start, int end, char key) {
            for (int i = start; i &lt;= end; i++) {
                if (inorder[i] == key) {
                    return i;
                }
            }
            return -1;
        }
        
        struct Node* buildTree(char preorder[], char inorder[], int start, int end, int* preIndex) {
            if (start &gt; end) {
                return NULL;
            }
        
            struct Node* node = (struct Node*)malloc(sizeof(struct Node));
            node-&gt;data = preorder[(*preIndex)++];
            node-&gt;left = NULL;
            node-&gt;right = NULL;
        
            if (start == end) {
                return node;
            }
        
            int inIndex = search(inorder, start, end, node-&gt;data);
        
            node-&gt;left = buildTree(preorder, inorder, start, inIndex - 1, preIndex);
            node-&gt;right = buildTree(preorder, inorder, inIndex + 1, end, preIndex);
        
            return node;
        }
        
        void inorderTraversal(struct Node* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%c ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            char preorder[100];
            char inorder[100];
            int n = 0;
        
            printf("Enter the preorder traversal: ");
            scanf("%s", preorder);
        
            printf("Enter the inorder traversal: ");
            scanf("%s", inorder);
        
            
            while (preorder[n] != '\0') 
            {
                n++;
            }
        
            int preIndex = 0;
            struct Node* root = buildTree(preorder, inorder, 0, n - 1, &preIndex);
        
            printf("Inorder traversal of constructed binary tree: ");
            inorderTraversal(root);
            printf("\n");
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the preorder traversal: ABDCE
        Enter the inorder traversal: DBACE
        Inorder traversal of constructed binary tree: D B A C E
        
        </pre> 
    <!-- Question 2 -->
    <h2 id="tr2">Question 2: Binary Tree Level Order Traversal</h2>
    <pre>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;
            
            struct Node {
                char data;
                struct Node* left;
                struct Node* right;
            };
            
            struct Node* createNode(char data) {
                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                newNode-&gt;data = data;
                newNode-&gt;left = NULL;
                newNode-&gt;right = NULL;
                return newNode;
            }
            
            void levelOrderTraversal(struct Node* root) {
                if (root == NULL) {
                    return;
                }
            
                struct Node** queue = (struct Node**)malloc(100 * sizeof(struct Node*));
                int front = 0, rear = 0;
            
                queue[rear++] = root;
            
                while (front &lt; rear) {
                    struct Node* current = queue[front++];
            
                    printf("%c ", current-&gt;data);
            
                    if (current-&gt;left != NULL) {
                        queue[rear++] = current-&gt;left;
                    }
            
                    if (current-&gt;right != NULL) {
                        queue[rear++] = current-&gt;right;
                    }
                }
            
                free(queue);
            }
            
            int main() {
                struct Node* root = createNode('A');
                root-&gt;left = createNode('B');
                root-&gt;right = createNode('C');
                root-&gt;left-&gt;left = createNode('D');
                root-&gt;left-&gt;right = createNode('E');
                root-&gt;right-&gt;left = createNode('F');
                root-&gt;right-&gt;right = createNode('G');
            
                printf("Level Order Traversal: ");
                levelOrderTraversal(root);
                printf("\n");
            
                return 0;
            }
            
            <h2>OUTPUT:-</h2>
            
            Level Order Traversal: A B C D E F G
            
            </pre>
            
    <!-- Question 3 -->
    <h2 id="tr3">Question 3: Print Left View of Binary Tree</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct Node {
            char data;
            struct Node* left;
            struct Node* right;
        };
        
        struct Node* createNode(char data) {
            struct Node* newNode = malloc(sizeof(struct Node));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        void leftViewUtil(struct Node* root, int level, int* maxLevel) {
            if (root == NULL) {
                return;
            }
            if (*maxLevel &lt; level) {
                printf("%c ", root-&gt;data);
                *maxLevel = level;
            }
            leftViewUtil(root-&gt;left, level + 1, maxLevel);
            leftViewUtil(root-&gt;right, level + 1, maxLevel);
        }
        
        void leftView(struct Node* root) {
            int maxLevel = 0;
            leftViewUtil(root, 1, &maxLevel);
        }
        
        int main() {
            struct Node* root = createNode('A');
            root-&gt;left = createNode('B');
            root-&gt;right = createNode('C');
            root-&gt;left-&gt;left = createNode('D');
            root-&gt;left-&gt;right = createNode('E');
            root-&gt;right-&gt;left = createNode('F');
            root-&gt;right-&gt;right = createNode('G');
            leftView(root);
            printf("\n");
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        A B D
        
        </pre>
    <!-- Question 4 -->
    <h2 id="tr4">Question 4: Display the Right View of Binary Tree</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct Node {
            char data;
            struct Node* left;
            struct Node* right;
        };
        
        struct Node* createNode(char data) {
            struct Node* newNode = malloc(sizeof(struct Node));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        void rightViewUtil(struct Node* root, int level, int* maxLevel) {
            if (root == NULL) {
                return;
            }
            if (*maxLevel &lt; level) {
                printf("%c ", root-&gt;data);
                *maxLevel = level;
            }
            rightViewUtil(root-&gt;right, level + 1, maxLevel);
            rightViewUtil(root-&gt;left, level + 1, maxLevel);
        }
        
        void rightView(struct Node* root) {
            int maxLevel = 0;
            rightViewUtil(root, 1, &maxLevel);
        }
        
        int main() {
            struct Node* root = createNode('A');
            root-&gt;left = createNode('B');
            root-&gt;right = createNode('C');
            root-&gt;left-&gt;left = createNode('D');
            root-&gt;left-&gt;right = createNode('E');
            root-&gt;right-&gt;left = createNode('F');
            root-&gt;right-&gt;right = createNode('G');
            rightView(root);
            printf("\n");
            return 0;
        }
        
    </pre>
    <pre><h2>OUTPUT</h2>
        A C G 
    </pre>

    <!-- Question 5 -->
    <h2 id="tr5">Question 5: Construct Binary Tree from Postorder and Inorder Traversal</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createTreeNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        int search(int inorder[], int start, int end, int data) {
            for (int i = start; i &lt;= end; i++) {
                if (inorder[i] == data) {
                    return i;
                }
            }
            return -1;
        }
        
        struct TreeNode* buildBinaryTree(int inorder[], int postorder[], int inStart, int inEnd, int* postIndex) {
            if (inStart &gt; inEnd) {
                return NULL;
            }
        
            struct TreeNode* root = createTreeNode(postorder[*postIndex]);
            (*postIndex)--;
        
            if (inStart == inEnd) {
                return root;
            }
        
            int inIndex = search(inorder, inStart, inEnd, root-&gt;data);
        
            root-&gt;right = buildBinaryTree(inorder, postorder, inIndex + 1, inEnd, postIndex);
            root-&gt;left = buildBinaryTree(inorder, postorder, inStart, inIndex - 1, postIndex);
        
            return root;
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root == NULL) {
                return;
            }
        
            inorderTraversal(root-&gt;left);
            printf("%d ", root-&gt;data);
            inorderTraversal(root-&gt;right);
        }
        
        int main() {
            int n;
            printf("Enter the number of nodes: ");
            scanf("%d", &n);
        
            int inorder[n], postorder[n];
        
            printf("Enter the inorder traversal: ");
            for (int i = 0; i &lt; n; i++) {
                scanf("%d", &inorder[i]);
            }
        
            printf("Enter the postorder traversal: ");
            for (int i = 0; i &lt; n; i++) {
                scanf("%d", &postorder[i]);
            }
        
            int postIndex = n - 1;
            struct TreeNode* root = buildBinaryTree(inorder, postorder, 0, n - 1, &postIndex);
        
            printf("Inorder traversal of the constructed binary tree: ");
            inorderTraversal(root);
            printf("\n");
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of nodes: 5
        Enter the inorder traversal: 4 2 5 1 3
        Enter the postorder traversal: 4 5 2 3 1
        Inorder traversal of the constructed binary tree: 4 2 5 1 3 
        
    </pre>
    <!-- Question 6 -->
    <h2 id="tr6">Question 6: Maximum depth of binary tree.</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createTreeNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        int maxDepth(struct TreeNode* root) {
            if (root == NULL) {
                return 0;
            }
            int leftDepth = maxDepth(root-&gt;left);
            int rightDepth = maxDepth(root-&gt;right);
            return (leftDepth &gt; rightDepth ? leftDepth : rightDepth) + 1;
        }
        
        int main() {
            struct TreeNode* root = createTreeNode(1);
            root-&gt;left = createTreeNode(2);
            root-&gt;right = createTreeNode(3);
            root-&gt;left-&gt;left = createTreeNode(4);
            root-&gt;left-&gt;right = createTreeNode(5);
        
            printf("Maximum depth of the binary tree: %d\n", maxDepth(root));
        
            return 0;
        }
    
        <h2>OUTPUT</h2>
        
        Maximum depth of the binary tree: 3
        
        </pre>

    <!-- Question 7 -->
    <h2 id="tr7">Question 7: Binary search tree using arrays</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
        int data;
        struct TreeNode* left;
        struct TreeNode* right;
        };
        
        struct TreeNode* createTreeNode(int data) {
        struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
        newNode-&gt;data = data;
        newNode-&gt;left = NULL;
        newNode-&gt;right = NULL;
        return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
        if (root == NULL) {
            return createTreeNode(data);
        }
        if (data &lt; root-&gt;data) {
            root-&gt;left = insert(root-&gt;left, data);
        } else if (data &gt; root-&gt;data) {
            root-&gt;right = insert(root-&gt;right, data);
        }
        return root;
        }
        
        struct TreeNode* search(struct TreeNode* root, int data) {
        if (root == NULL || root-&gt;data == data) {
            return root;
        }
        if (data &lt; root-&gt;data) {
            return search(root-&gt;left, data);
        }
        return search(root-&gt;right, data);
        }
        
        struct TreeNode* findMinimum(struct TreeNode* root) {
        while (root-&gt;left != NULL) {
            root = root-&gt;left;
        }
        return root;
        }
        
        struct TreeNode* deleteNode(struct TreeNode* root, int data) {
        if (root == NULL) {
            return root;
        }
        if (data &lt; root-&gt;data) {
            root-&gt;left = deleteNode(root-&gt;left, data);
        } else if (data &gt; root-&gt;data) {
            root-&gt;right = deleteNode(root-&gt;right, data);
        } else {
            if (root-&gt;left == NULL) {
                struct TreeNode* temp = root-&gt;right;
                free(root);
                return temp;
            } else if (root-&gt;right == NULL) {
                struct TreeNode* temp = root-&gt;left;
                free(root);
                return temp;
            }
            struct TreeNode* temp = findMinimum(root-&gt;right);
            root-&gt;data = temp-&gt;data;
            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);
        }
        return root;
        }
        
        void preorderTraversal(struct TreeNode* root) {
        if (root != NULL) {
            printf("%d ", root-&gt;data);
            preorderTraversal(root-&gt;left);
            preorderTraversal(root-&gt;right);
        }
        }
        
        void inorderTraversal(struct TreeNode* root) {
        if (root != NULL) {
            inorderTraversal(root-&gt;left);
            printf("%d ", root-&gt;data);
            inorderTraversal(root-&gt;right);
        }
        }
        
        void postorderTraversal(struct TreeNode* root) {
        if (root != NULL) {
            postorderTraversal(root-&gt;left);
            postorderTraversal(root-&gt;right);
            printf("%d ", root-&gt;data);
        }
        }
        
        int main() {
        struct TreeNode* root = NULL;
        int choice, data;
        printf("\n1. Insert\n2. Delete\n3. Search\n4. Preorder Traversal\n5.Inorder Traversal\n6. Postorder <br>Traversal\n7. Find Minimum Element\n8. Exit\n");
        while (1) {
            printf("Enter your choice: ");
            scanf("%d", &choice);
        
            switch (choice) {
                case 1 {
                    printf("Enter data to insert: ");
                    scanf("%d", &data);
                    root = insert(root, data);
                    break;
                }
                case 2 {
                    printf("Enter data to delete: ");
                    scanf("%d", &data);
                    root = deleteNode(root, data);
                    break;
                }
                case 3 {
                    printf("Enter data to search: ");
                    scanf("%d", &data);
                    struct TreeNode* foundNode = search(root, data);
                    if (foundNode) {
                        printf("Element %d found.\n", data);
                    } else {
                        printf("Element %d not found.\n", data);
                    }
                    break;
                }
                case 4 {
                    printf("Preorder Traversal: ");
                    preorderTraversal(root);
                    printf("\n");
                    break;
                }
                case 5 {
                    printf("Inorder Traversal: ");
                    inorderTraversal(root);
                    printf("\n");
                    break;
                }
                case 6 {
                    printf("Postorder Traversal: ");
                    postorderTraversal(root);
                    printf("\n");
                    break;
                }
                case 7 {
                    struct TreeNode* minNode = findMinimum(root);
                    if (minNode) {
                        printf("Minimum element: %d\n", minNode-&gt;data);
                    } else {
                        printf("Tree is empty.\n");
                    }
                    break;
                }
                case 8 {
                    exit(0);
                }
                default {
                    printf("Invalid choice!\n");
                    break;
                }
            }
        }
        }
        
        <h2>OUTPUT</h2>
        
        
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        
        
        Enter your choice: 1
        Enter data to insert: 15
        
        
        Enter your choice: 1
        Enter data to insert: 10
        
        
        Enter your choice: 1
        Enter data to insert: 20
        
        
        Enter your choice: 4
        Preorder Traversal: 15 10 20 
        
        
        Enter your choice: 5
        Inorder Traversal: 10 15 20 
        
        
        Enter your choice: 6
        Postorder Traversal: 10 20 15 
        
        
        Enter your choice: 3
        Enter data to search: 10
        Element 10 found.
        
        
        Enter your choice: 7
        Minimum element: 10
        
        Enter your choice: 2
        Enter data to delete: 10
        
        Enter your choice: 5
        Inorder Traversal: 15 20 
        
        Enter your choice: 8
        
    </pre>
    <!-- Question 8 -->
    <h2 id="tr8">Question 8: Binary search tree dynamically</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createTreeNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) { return createTreeNode(data); }
            if (data &lt; root-&gt;data) { root-&gt;left = insert(root-&gt;left, data); }
            else if (data &gt; root-&gt;data) { root-&gt;right = insert(root-&gt;right, data); }
            return root;
        }
        
        struct TreeNode* search(struct TreeNode* root, int data) {
            if (root == NULL || root-&gt;data == data) { return root; }
            if (data &lt; root-&gt;data) { return search(root-&gt;left, data); }
            return search(root-&gt;right, data);
        }
        
        struct TreeNode* findMinimum(struct TreeNode* root) {
            while (root-&gt;left != NULL) { root = root-&gt;left; }
            return root;
        }
        
        struct TreeNode* deleteNode(struct TreeNode* root, int data) {
            if (root == NULL) { return root; }
            if (data &lt; root-&gt;data) { root-&gt;left = deleteNode(root-&gt;left, data); }
            else if (data &gt; root-&gt;data) { root-&gt;right = deleteNode(root-&gt;right, data); }
            else {
                if (root-&gt;left == NULL) {
                    struct TreeNode* temp = root-&gt;right;
                    free(root);
                    return temp;
                } else if (root-&gt;right == NULL) {
                    struct TreeNode* temp = root-&gt;left;
                    free(root);
                    return temp;
                }
                struct TreeNode* temp = findMinimum(root-&gt;right);
                root-&gt;data = temp-&gt;data;
                root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);
            }
            return root;
        }
        
        void preorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                printf("%d ", root-&gt;data);
                preorderTraversal(root-&gt;left);
                preorderTraversal(root-&gt;right);
            }
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        void postorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                postorderTraversal(root-&gt;left);
                postorderTraversal(root-&gt;right);
                printf("%d ", root-&gt;data);
            }
        }
        
        int main() {
            struct TreeNode* root = NULL;
            int choice, data;
        
            while (1) {
                printf("\n1. Insert\n2. Delete\n3. Search\n4. Preorder Traversal\n5. Inorder Traversal\n6. Postorder<br> Traversal\n7. Find Minimum Element\n8. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1 {
                        printf("Enter data to insert: ");
                        scanf("%d", &data);
                        root = insert(root, data);
                        break;
                    }
                    case 2 {
                        printf("Enter data to delete: ");
                        scanf("%d", &data);
                        root = deleteNode(root, data);
                        break;
                    }
                    case 3 {
                        printf("Enter data to search: ");
                        scanf("%d", &data);
                        struct TreeNode* foundNode = search(root, data);
                        if (foundNode) { printf("Element %d found.\n", data); }
                        else { printf("Element %d not found.\n", data); }
                        break;
                    }
                    case 4 {
                        printf("Preorder Traversal: ");
                        preorderTraversal(root);
                        printf("\n");
                        break;
                    }
                    case 5 {
                        printf("Inorder Traversal: ");
                        inorderTraversal(root);
                        printf("\n");
                        break;
                    }
                    case 6 {
                        printf("Postorder Traversal: ");
                        postorderTraversal(root);
                        printf("\n");
                        break;
                    }
                    case 7 {
                        struct TreeNode* minNode = findMinimum(root);
                        if (minNode) { printf("Minimum element: %d\n", minNode-&gt;data); }
                        else { printf("Tree is empty.\n"); }
                        break;
                    }
                    case 8 { exit(0); }
                    default { printf("Invalid choice!\n"); break; }
                }
            }
        }
        
        <h2>OUTPUT</h2>
    
    1. Insert
    2. Delete
    3. Search
    4. Preorder Traversal
    5. Inorder Traversal
    6. Postorder Traversal
    7. Find Minimum Element
    8. Exit
    Enter your choice: 1
    Enter data to insert: 15
    Enter your choice: 1
    Enter data to insert: 10
    Enter your choice: 1
    Enter data to insert: 20
    Enter your choice: 5
    Inorder Traversal: 10 15 20
    Enter your choice: 8

    </pre>
    <!-- Question 9 -->
    <h2 id="tr9">Question 9: Find inorder predecessor and inorder successor</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createTreeNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) { return createTreeNode(data); }
            if (data &lt; root-&gt;data) { root-&gt;left = insert(root-&gt;left, data); }
            else if (data &gt; root-&gt;data) { root-&gt;right = insert(root-&gt;right, data); }
            return root;
        }
        
        struct TreeNode* findMax(struct TreeNode* root) {
            while (root-&gt;right != NULL) { root = root-&gt;right; }
            return root;
        }
        
        struct TreeNode* findMin(struct TreeNode* root) {
            while (root-&gt;left != NULL) { root = root-&gt;left; }
            return root;
        }
        
        void findPredecessorSuccessor(struct TreeNode* root, struct TreeNode** predecessor, struct<br> TreeNode** successor, int key) {
            if (root == NULL) { return; }
            if (root-&gt;data == key) {
                if (root-&gt;left != NULL) { *predecessor = findMax(root-&gt;left); }
                if (root-&gt;right != NULL) { *successor = findMin(root-&gt;right); }
            } else if (key &lt; root-&gt;data) {
                *successor = root;
                findPredecessorSuccessor(root-&gt;left, predecessor, successor, key);
            } else {
                *predecessor = root;
                findPredecessorSuccessor(root-&gt;right, predecessor, successor, key);
            }
        }
        
        int main() {
            struct TreeNode* root = NULL;
            int choice, data, key;
            struct TreeNode *predecessor = NULL, *successor = NULL;
        
            printf("Binary Search Tree Operations:\n1. Insert\n2. Find Inorder Predecessor and Successor\n3. Exit\n");
        
            while (1) {
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1 {
                        printf("Enter data to insert: ");
                        scanf("%d", &data);
                        root = insert(root, data);
                        break;
                    }
                    case 2 {
                        printf("Enter the key to find predecessor and successor: ");
                        scanf("%d", &key);
                        predecessor = successor = NULL;
                        findPredecessorSuccessor(root, &predecessor, &successor, key);
        
                        if (predecessor) { printf("Inorder Predecessor: %d\n", predecessor-&gt;data); }
                        else { printf("Inorder Predecessor: None\n"); }
        
                        if (successor) { printf("Inorder Successor: %d\n", successor-&gt;data); }
                        else { printf("Inorder Successor: None\n"); }
                        break;
                    }
                    case 3 { exit(0); }
                    default { printf("Invalid choice!\n"); break; }
                }
            }
            return 0;
        }

        <h2>OUTPUT</h2>
    
    Binary Search Tree Operations:
    1. Insert
    2. Find Inorder Predecessor and Successor
    3. Exit
    
    Enter your choice: 1
    Enter data to insert: 20
    Enter your choice: 1
    Enter data to insert: 10
    Enter your choice: 1
    Enter data to insert: 30
    Enter your choice: 1
    Enter data to insert: 25
    Enter your choice: 2
    Enter the key to find predecessor and successor: 20
    Inorder Predecessor: 10
    Inorder Successor: 25
    Enter your choice: 3
    
    </pre>
    <!-- Question 10 -->
    <h2 id="tr10">Question 10: Check dead ends of binary search tree </h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createTreeNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) { return createTreeNode(data); }
            if (data &lt; root-&gt;data) { root-&gt;left = insert(root-&gt;left, data); }
            else if (data &gt; root-&gt;data) { root-&gt;right = insert(root-&gt;right, data); }
            return root;
        }
        
        int checkDeadEnd(struct TreeNode* root, int min, int max) {
            if (root == NULL) { return 0; }
            if (min == max) { return 1; }
            return checkDeadEnd(root-&gt;left, min, root-&gt;data - 1) || checkDeadEnd(root-&gt;right, root-&gt;data + 1, max);
        }
        
        int main() {
            struct TreeNode* root = NULL;
            int choice, data;
        
            printf("Binary Search Tree Operations:\n1. Insert\n2. Check Dead End\n3. Exit\n");
        
            while (1) {
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1 {
                        printf("Enter data to insert: ");
                        scanf("%d", &data);
                        root = insert(root, data);
                        break;
                    }
                    case 2 {
                        if (checkDeadEnd(root, 1, 2147483647)) {
                            printf("The BST contains a dead end.\n");
                        } else {
                            printf("The BST does not contain any dead ends.\n");
                        }
                        break;
                    }
                    case 3 { exit(0); }
                    default { printf("Invalid choice!\n"); break; }
                }
            }
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Binary Search Tree Operations:
        1. Insert
        2. Check Dead End
        3. Exit
        
        Enter your choice: 1
        Enter data to insert: 8
        Enter your choice: 1
        Enter data to insert: 5
        Enter your choice: 1
        Enter data to insert: 9
        Enter your choice: 1
        Enter data to insert: 2
        Enter your choice: 1
        Enter data to insert: 7
        Enter your choice: 2
        The BST contains a dead end.
        
        Enter your choice: 3
        
    </pre>
    <!-- Question 11 -->
    <h2 id="tr11">Question 11: Create binary tree to binary search tree</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) {
                return createNode(data);
            }
            if (data &lt; root-&gt;data) {
                root-&gt;left = insert(root-&gt;left, data);
            } else {
                root-&gt;right = insert(root-&gt;right, data);
            }
            return root;
        }
        
        void inOrderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inOrderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inOrderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            int n, i, data;
            struct TreeNode* root = NULL;
        
            printf("Enter the number of elements in the array: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            int* arr = (int*)malloc(n * sizeof(int));
        
            printf("Enter the elements of the array:\n");
            for (i = 0; i &lt; n; i++) {
                scanf("%d", &data);
                arr[i] = data;
            }
        
            for (i = 0; i &lt; n; i++) {
                root = insert(root, arr[i]);
            }
        
            printf("Binary Search Tree (BST) created from the array:\n");
            inOrderTraversal(root);
            printf("\n");
        
            free(arr);
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of elements in the array: 7
        Enter the elements of the array:
        50
        30
        70
        20
        40
        60
        80
        Binary Search Tree (BST) created from the array:
        20 30 40 50 60 70 80
        
    </pre>
    <!-- Question 12 -->
    <h2 id="tr12">Question 12: Find kth largest element in binary search tree</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) {
                return createNode(data);
            }
            if (data &lt; root-&gt;data) {
                root-&gt;left = insert(root-&gt;left, data);
            } else {
                root-&gt;right = insert(root-&gt;right, data);
            }
            return root;
        }
        
        void inOrderTraversal(struct TreeNode* root, int* array, int* index) {
            if (root != NULL) {
                inOrderTraversal(root-&gt;left, array, index);
                array[*index] = root-&gt;data;
                (*index)++;
                inOrderTraversal(root-&gt;right, array, index);
            }
        }
        
        int findKthLargest(struct TreeNode* root, int k) {
            int* array = (int*)malloc(sizeof(int) * k);
            int index = 0;
            inOrderTraversal(root, array, &index);
            int kthLargest = array[index - k];
            free(array);
            return kthLargest;
        }
        
        int main() {
            int n, i, data, k;
        
            printf("Enter the number of elements in the array: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            int* arr = (int*)malloc(n * sizeof(int));
        
            printf("Enter the elements of the array:\n");
            for (i = 0; i &lt; n; i++) {
                scanf("%d", &data);
                arr[i] = data;
            }
        
            struct TreeNode* root = NULL;
            for (i = 0; i &lt; n; i++) {
                root = insert(root, arr[i]);
            }
        
            printf("Enter the value of K to find the Kth largest element: ");
            scanf("%d", &k);
        
            int kthLargest = findKthLargest(root, k);
        
            printf("The %dth largest element in the BST is: %d\n", k, kthLargest);
        
            free(arr);
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of elements in the array: 5
        Enter the elements of the array:
        20
        15
        25
        10
        30
        Enter the value of K to find the Kth largest element: 2
        The 2th largest element in the BST is: 25
        </pre>
    <!-- Question 13 -->
    <h2 id="tr13">Question 13: Find kth smallest element in a binary search tree</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) {
                return createNode(data);
            }
            if (data &lt; root-&gt;data) {
                root-&gt;left = insert(root-&gt;left, data);
            } else {
                root-&gt;right = insert(root-&gt;right, data);
            }
            return root;
        }
        
        void inOrderTraversal(struct TreeNode* root, int* array, int* index) {
            if (root != NULL) {
                inOrderTraversal(root-&gt;left, array, index);
                array[*index] = root-&gt;data;
                (*index)++;
                inOrderTraversal(root-&gt;right, array, index);
            }
        }
        
        int findKthSmallest(struct TreeNode* root, int k) {
            int* array = (int*)malloc(sizeof(int) * k);
            int index = 0;
            inOrderTraversal(root, array, &index);
            int kthSmallest = array[k - 1];
            free(array);
            return kthSmallest;
        }
        
        int main() {
            int n, i, data, k;
        
            printf("Enter the number of elements in the array: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            int* arr = (int*)malloc(n * sizeof(int));
        
            printf("Enter the elements of the array:\n");
            for (i = 0; i &lt; n; i++) {
                scanf("%d", &data);
                arr[i] = data;
            }
        
            struct TreeNode* root = NULL;
            for (i = 0; i &lt; n; i++) {
                root = insert(root, arr[i]);
            }
        
            printf("Enter the value of K to find the Kth smallest element: ");
            scanf("%d", &k);
        
            int kthSmallest = findKthSmallest(root, k);
        
            printf("The %dth smallest element in the BST is: %d\n", k, kthSmallest);
        
            free(arr);
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of elements in the array: 5
        Enter the elements of the array:
        20
        15
        25
        10
        30
        Enter the value of K to find the Kth smallest element: 3
        The 3th smallest element in the BST is: 20
    </pre>
    <!-- Question 14 -->
    <h2 id="tr14">Question 14: Print preorder traversal to postorder traversal</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) {
                return createNode(data);
            }
            if (data &lt; root-&gt;data) {
                root-&gt;left = insert(root-&gt;left, data);
            } else {
                root-&gt;right = insert(root-&gt;right, data);
            }
            return root;
        }
        
        void preorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                printf("%d ", root-&gt;data);
                preorderTraversal(root-&gt;left);
                preorderTraversal(root-&gt;right);
            }
        }
        
        void postorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                postorderTraversal(root-&gt;left);
                postorderTraversal(root-&gt;right);
                printf("%d ", root-&gt;data);
            }
        }
        
        int main() {
            struct TreeNode* root = NULL;
            int n, data;
        
            printf("Enter the number of elements in the BST: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            printf("Enter the elements of the BST:\n");
            for (int i = 0; i &lt; n; i++) {
                scanf("%d", &data);
                root = insert(root, data);
            }
        
            printf("Preorder Traversal: ");
            preorderTraversal(root);
            printf("\n");
        
            printf("Postorder Traversal: ");
            postorderTraversal(root);
            printf("\n");
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of elements in the BST: 5
        Enter the elements of the BST:
        10
        5
        15
        3
        7
        Preorder Traversal: 10 5 3 7 15 
        Postorder Traversal: 3 7 5 15 10 
        
    </pre>
    <!-- Question 15 -->
    <h2 id="tr15">Question 15: Binary search tree from preorder traversal</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* constructBST(int preorder[], int n) {
            struct TreeNode* root = NULL;
            if (n &lt;= 0) {
                return root;
            }
            
            root = createNode(preorder[0]);
            int i;
            for (i = 1; i &lt; n; i++) {
                if (preorder[i] &gt; root-&gt;data) {
                    break;
                }
            }
            
            root-&gt;left = constructBST(preorder + 1, i - 1);
            root-&gt;right = constructBST(preorder + i, n - i);
            
            return root;
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            int n, i;
        
            printf("Enter the number of elements in the preorder traversal: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            int* preorder = (int*)malloc(n * sizeof(int));
        
            printf("Enter the elements in preorder traversal:\n");
            for (i = 0; i &lt; n; i++) {
                scanf("%d", &preorder[i]);
            }
        
            struct TreeNode* root = constructBST(preorder, n);
        
            printf("Inorder Traversal of Constructed BST: ");
            inorderTraversal(root);
            printf("\n");
        
            free(preorder);
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of elements in the preorder traversal: 5
        Enter the elements in preorder traversal:
        10
        5
        1
        7
        15
        Inorder Traversal of Constructed BST: 1 5 7 10 15 
        
    </pre>
    <!-- Question 16 -->
    <h2 id="tr16">Question 16: Binary search tree from postorder traversal</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* constructBST(int postorder[], int n) {
            if (n &lt;= 0) {
                return NULL;
            }
            
            struct TreeNode* root = createNode(postorder[n - 1]);
            int i;
            
            for (i = n - 2; i &gt;= 0; i--) {
                if (postorder[i] &lt; root-&gt;data) {
                    break;
                }
            }
            
            root-&gt;right = constructBST(postorder + i + 1, n - i - 1);
            root-&gt;left = constructBST(postorder, i + 1);
            
            return root;
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            int n, i;
        
            printf("Enter the number of elements in the postorder traversal: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            int* postorder = (int*)malloc(n * sizeof(int));
        
            printf("Enter the elements in postorder traversal:\n");
            for (i = 0; i &lt; n; i++) {
                scanf("%d", &postorder[i]);
            }
        
            struct TreeNode* root = constructBST(postorder, n);
        
            printf("Inorder Traversal of Constructed BST: ");
            inorderTraversal(root);
            printf("\n");
        
            free(postorder);
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of elements in the postorder traversal: 7
        Enter the elements in postorder traversal:
        20
        40
        30
        60
        80
        70
        50
        Inorder Traversal of Constructed BST: 20 30 40 50 60 70 80  
        
    </pre>
    <!-- Question 17 -->
    <h2 id="tr17">Question 17: Create strictly binary tree(dynamically)</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* createStrictBinaryTree() {
            int data;
            printf("Enter data for the root node: ");
            scanf("%d", &data);
        
            if (data == -1) {
                return NULL;
            }
        
            struct TreeNode* root = createNode(data);
        
            printf("Enter left child for %d: ", data);
            root-&gt;left = createStrictBinaryTree();
        
            printf("Enter right child for %d: ", data);
            root-&gt;right = createStrictBinaryTree();
        
            return root;
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            struct TreeNode* root = createStrictBinaryTree();
        
            printf("Inorder Traversal of the Strictly Binary Tree: ");
            inorderTraversal(root);
            printf("\n");
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter data for the root node: 1
        Enter left child for 1: 2
        Enter right child for 1: 3
        Enter left child for 2: -1
        Enter right child for 2: -1
        Enter left child for 3: -1
        Enter right child for 3: -1
        Inorder Traversal of the Strictly Binary Tree: 2 1 3 
        
    </pre>
    <!-- Question 18 -->
    <h2 id="tr18">Question 18: Create almost complete binary tree(dynamically)</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* createAlmostCompleteBinaryTree() {
            int data;
            printf("Enter data for the root node: ");
            scanf("%d", &data);
        
            struct TreeNode* root = createNode(data);
            struct TreeNode* queue[1000];
            int front = 0, rear = 0;
            queue[rear++] = root;
        
            while (front &lt; rear) {
                struct TreeNode* current = queue[front++];
                printf("Enter left child for %d (-1 for no child): ", current-&gt;data);
                scanf("%d", &data);
                if (data != -1) {
                    current-&gt;left = createNode(data);
                    queue[rear++] = current-&gt;left;
                }
                printf("Enter right child for %d (-1 for no child): ", current-&gt;data);
                scanf("%d", &data);
                if (data != -1) {
                    current-&gt;right = createNode(data);
                    queue[rear++] = current-&gt;right;
                }
            }
        
            return root;
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            struct TreeNode* root = createAlmostCompleteBinaryTree();
        
            printf("Inorder Traversal of the Almost Complete Binary Tree: ");
            inorderTraversal(root);
            printf("\n");
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter data for the root node: 1
        Enter left child for 1 (-1 for no child): 2
        Enter right child for 1 (-1 for no child): 3
        Enter left child for 2 (-1 for no child): 4
        Enter right child for 2 (-1 for no child): 5
        Enter left child for 3 (-1 for no child): -1
        Enter right child for 3 (-1 for no child): 6
        Enter left child for 4 (-1 for no child): -1
        Enter right child for 4 (-1 for no child): -1
        Enter left child for 5 (-1 for no child): -1
        Enter right child for 5 (-1 for no child): -1
        Enter left child for 6 (-1 for no child): -1
        Enter right child for 6 (-1 for no child): -1
        Inorder Traversal of the Almost Complete Binary Tree: 4 2 5 1 3 6
        
    </pre>
    <!-- Question 19 -->
    <h2 id="tr19">Question 19: Create complete binary tree(dynamically)</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* createCompleteBinaryTree() {
            int data;
            printf("Enter data for the root node: ");
            scanf("%d", &data);
        
            struct TreeNode* root = createNode(data);
            struct TreeNode* queue[1000];
            int front = 0, rear = 0;
            queue[rear++] = root;
        
            while (front &lt; rear) {
                struct TreeNode* current = queue[front++];
                printf("Enter left child for %d (-1 for no child): ", current-&gt;data);
                scanf("%d", &data);
                if (data != -1) {
                    current-&gt;left = createNode(data);
                    queue[rear++] = current-&gt;left;
                }
                printf("Enter right child for %d (-1 for no child): ", current-&gt;data);
                scanf("%d", &data);
                if (data != -1) {
                    current-&gt;right = createNode(data);
                    queue[rear++] = current-&gt;right;
                }
            }
        
            return root;
        }
        
        void inorderTraversal(struct TreeNode* root) {
            if (root != NULL) {
                inorderTraversal(root-&gt;left);
                printf("%d ", root-&gt;data);
                inorderTraversal(root-&gt;right);
            }
        }
        
        int main() {
            struct TreeNode* root = createCompleteBinaryTree();
        
            printf("Inorder Traversal of the Complete Binary Tree: ");
            inorderTraversal(root);
            printf("\n");
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter data for the root node: 10
        Enter left child for 10 (-1 for no child): 5
        Enter right child for 10 (-1 for no child): 15
        Enter left child for 5 (-1 for no child): 3
        Enter right child for 5 (-1 for no child): 7
        Enter left child for 15 (-1 for no child): -1
        Enter right child for 15 (-1 for no child): 20
        Enter left child for 3 (-1 for no child): -1
        Enter right child for 3 (-1 for no child): -1
        Enter left child for 7 (-1 for no child): -1
        Enter right child for 7 (-1 for no child): -1
        Enter left child for 20 (-1 for no child): -1
        Enter right child for 20 (-1 for no child): -1
        Inorder Traversal of the Complete Binary Tree: 3 5 7 10 15 20 

    </pre>
    <!-- Question 20 -->
    <h2 id="tr20">Question 20: Count the number of nodes(Dynamically)</h2>
    <pre>
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;
        
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* createNode(int data) {
            struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
            newNode-&gt;data = data;
            newNode-&gt;left = NULL;
            newNode-&gt;right = NULL;
            return newNode;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int data) {
            if (root == NULL) {
                return createNode(data);
            }
            if (data &lt; root-&gt;data) {
                root-&gt;left = insert(root-&gt;left, data);
            } else {
                root-&gt;right = insert(root-&gt;right, data);
            }
            return root;
        }
        
        int countNodes(struct TreeNode* root) {
            if (root == NULL) {
                return 0;
            }
            return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);
        }
        
        int main() {
            struct TreeNode* root = NULL;
            int n, i, data;
        
            printf("Enter the number of nodes in the BST: ");
            scanf("%d", &n);
        
            if (n &lt;= 0) {
                printf("Invalid input.\n");
                return 1;
            }
        
            printf("Enter the elements of the BST:\n");
            for (i = 0; i &lt; n; i++) {
                scanf("%d", &data);
                root = insert(root, data);
            }
        
            int nodeCount = countNodes(root);
            printf("Number of nodes in the BST: %d\n", nodeCount);
        
            return 0;
        }
        
        <h2>OUTPUT</h2>
        
        Enter the number of nodes in the BST: 5
        Enter the elements of the BST:
        10
        5
        15
        3
        7
        Number of nodes in the BST: 5
        
    </pre>

                <!-- Back to Top Button -->
                <button class="back-to-top">Back to Top</button>
            </div>
        </section>
    </div>
    <script>
        // Show the back-to-top button when user scrolls down
        window.onscroll = function () {
            var backToTopBtn = document.querySelector('.back-to-top');
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = 'block';
            } else {
                backToTopBtn.style.display = 'none';
            }
        };
        // Scroll back to top when button is clicked
        document.querySelector('.back-to-top').onclick = function () {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };
    </script>
</body>
</html>
