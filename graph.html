<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Operations</title>
    <style>
        /* General reset */
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background-color: #1c1c1e;
    color: #d1d1d6;
    line-height: 1.6;
    padding: 20px;
}

.container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}

.main-content {
    flex-grow: 1;
    padding: 20px;
}

.box-main {
    max-width: 800px;
    width: 100%;
    background-color: #2c2c2e;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    border: 2px solid #3f3f42;
}

h1 {
    color: white;
    margin-bottom: 20px;
    text-align: center;
}

.firsthalf2 ul {
    list-style: none;
    padding:0;
}

.firsthalf2 li {
    margin:10px 0;
}

.firsthalf2 a {
    text-decoration: none;
    font-size: 18px;
    color: white;
    transition: color 0.3s ease;
}

.firsthalf2 a:hover {
    color: #6a6aff;
}

h2 {
    color: white;
    margin-top: 20px;
    border-bottom: 2px solid #3f3f42;
    padding-bottom: 5px;
    font-size: 26px;
}

.vasu {
    color: #d1d1d6;
    max-width: 1000px;
    font-size: large;
    width: auto;
    background-color: #2c2c2e;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    margin-top: 10px;
}

.vasu pre {
    word-wrap: break-word;
    white-space: pre-wrap;
    max-width: 100%;
    overflow-x: auto;
    background-color: #3a3a3c;
    border-radius: 4px;
    padding: 10px;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
    margin-bottom: 20px;
    border: 1px solid #5a5a5f;
    color: #f4f4f5;
}

.back-to-top {
    position: fixed;
    bottom: 20px;
    right: 10px;
    background-color: #6a6aff;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 10px 15px;
    cursor: pointer;
    display: none;
    z-index: 1000;
    transition: background-color 0.3s ease;
}

.back-to-top:hover {
    background-color: #4f4fcc;
}

@media (max-width: 600px) {
    .box-main {
        padding: 20px;
    }

    .firsthalf2 a {
        font-size: 16px;
    }

    .back-to-top {
        font-size: 14px;
        padding: 8px 12px;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Main Content -->
        <section class="main-content">
            <div class="box-main">
                <h1>Graph Operations</h1>
                <div class="firsthalf2">
                    <ul>
                        <li><a href="#g-q1">1. Enter the vertices and edges, represent them in an adjacency matrix, and print it.</a></li>
                        <li><a href="#g-q2">2. Create the graph as an adjacency list with operations such as insertion and deletion.</a></li>
                        <li><a href="#g-q3">3. Traverse the adjacency matrix using Depth First Search (DFS).</a></li>
                        <li><a href="#g-q4">4. Traverse the adjacency list using Depth First Search (DFS).</a></li>
                        <li><a href="#g-q5">5. Traverse the adjacency matrix using Breadth First Search (BFS).</a></li>
                        <li><a href="#g-q6">6. Traverse the adjacency list using Breadth First Search (BFS).</a></li>
                    </ul>
                </div>
 <!-- Question 1 -->
<h2 id="g-q1">Question 1: Adjacency Matrix Representation</h2>
<pre>
#include &lt;stdio.h&gt;

int main() {
int vertices, edges;

printf("Enter the number of vertices in the graph: ");
scanf("%d", &vertices);

printf("Enter the number of edges in the graph: ");
scanf("%d", &edges);

int adjacencyMatrix[vertices][vertices];

for (int i = 0; i &lt; vertices; i++) {
    for (int j = 0; j &lt; vertices; j++) {
        adjacencyMatrix[i][j] = 0;
    }
}

for (int i = 0; i &lt; edges; i++) {
    int source, destination;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &source, &destination);

    if (source &gt;= 0 && source &lt; vertices && destination &gt;= 0 && destination &lt; vertices) {
        adjacencyMatrix[source][destination] = 1;
        adjacencyMatrix[destination][source] = 1;
    } else {
        printf("Invalid vertex indices. Please enter valid indices.\n");
        i--;
    }
}

printf("Adjacency Matrix:\n");
for (int i = 0; i &lt; vertices; i++) {
    for (int j = 0; j &lt; vertices; j++) {
        printf("%d ", adjacencyMatrix[i][j]);
    }
    printf("\n");
}

return 0;
}

<pre><h2>OUTPUT</h2></pre>

Enter the number of vertices in the graph: 3
Enter the number of edges in the graph: 3
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 1 2
Enter edge 3 (source destination): 0 2
Adjacency Matrix:
0 1 1 
1 0 1 
1 1 0 
</pre>
<!-- Question 2 -->
<h2 id="g-q2">Question 2: Adjacency List Representation with Operations</h2>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode-&gt;data = data;
newNode-&gt;next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph-&gt;V = V;
graph-&gt;adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph-&gt;adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph-&gt;adjList[src];
graph-&gt;adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph-&gt;adjList[dest];
graph-&gt;adjList[dest] = newNode;
}

void deleteEdge(struct Graph* graph, int src, int dest) {
struct Node* current = graph-&gt;adjList[src];
struct Node* prev = NULL;

while (current != NULL && current-&gt;data != dest) {
    prev = current;
    current = current-&gt;next;
}

if (current == NULL) {
    return;
}

if (prev == NULL) {
    graph-&gt;adjList[src] = current-&gt;next;
} else {
    prev-&gt;next = current-&gt;next;
}

free(current);

current = graph-&gt;adjList[dest];
prev = NULL;

while (current != NULL && current-&gt;data != src) {
    prev = current;
    current = current-&gt;next;
}

if (prev == NULL) {
    graph-&gt;adjList[dest] = current-&gt;next;
} else {
    prev-&gt;next = current-&gt;next;
}

free(current);
}

void displayGraph(struct Graph* graph) {
for (int i = 0; i &lt; graph-&gt;V; i++) {
    struct Node* current = graph-&gt;adjList[i];
    printf("Adjacency list of vertex %d: ", i);
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

printf("Graph before deletion:\n");
displayGraph(graph);

int src, dest;
printf("Enter edge to delete (source destination): ");
scanf("%d %d", &src, &dest);
deleteEdge(graph, src, dest);

printf("Graph after deletion:\n");
displayGraph(graph);

return 0;
}


<pre><h2>OUTPUT</h2></pre>

Enter the number of vertices: 4
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 2
Enter edge 3 (source destination): 1 2
Enter edge 4 (source destination): 2 3
Graph before deletion:
Adjacency list of vertex 0: 2 -&gt; 1 -&gt; NULL
Adjacency list of vertex 1: 2 -&gt; 0 -&gt; NULL
Adjacency list of vertex 2: 3 -&gt; 1 -&gt; 0 -&gt; NULL
Adjacency list of vertex 3: 2 -&gt; NULL
Enter edge to delete (source destination): 0 1
Graph after deletion:
Adjacency list of vertex 0: 2 -&gt; NULL
Adjacency list of vertex 1: NULL
Adjacency list of vertex 2: 3 -&gt; NULL
Adjacency list of vertex 3: 2 -&gt; NULL
</pre>
<!-- Question 3 -->
<h2 id="g-q3">Question 3: Depth First Search on Adjacency Matrix</h2>
<pre>
#include &lt;stdio.h&gt;

void depthFirstSearch(int vertex, int V, int adjacencyMatrix[V][V], int visited[]) {
printf("%d ", vertex);
visited[vertex] = 1;

for (int i = 0; i &lt; V; i++) {
    if (adjacencyMatrix[vertex][i] == 1 && !visited[i]) {
        depthFirstSearch(i, V, adjacencyMatrix, visited);
    }
}
}

int main() {
int V;

printf("Enter the number of vertices: ");
scanf("%d", &V);

int adjacencyMatrix[V][V];

printf("Enter the adjacency matrix (%d x %d):\n", V, V);
for (int i = 0; i &lt; V; i++) {
    for (int j = 0; j &lt; V; j++) {
        scanf("%d", &adjacencyMatrix[i][j]);
    }
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

printf("Enter the starting vertex for DFS: ");
int startVertex;
scanf("%d", &startVertex);

printf("Depth-First Search Traversal starting from vertex %d: ", startVertex);
depthFirstSearch(startVertex, V, adjacencyMatrix, visited);
printf("\n");

return 0;
}

<pre><h2>OUTPUT</h2></pre>
    
Enter the number of vertices: 4
Enter the adjacency matrix (4 x 4):
0 1 0 1
1 0 1 0
0 1 0 0
1 0 0 0
Enter the starting vertex for DFS: 0
Depth-First Search Traversal starting from vertex 0: 0 1 2 3 

</pre>
<!-- Question 4 -->
<h2 id="g-q4">Question 4: Depth First Search on Adjacency List</h2>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode->data = data;
newNode->next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph->V = V;
graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph->adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph->adjList[src];
graph->adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph->adjList[dest];
graph->adjList[dest] = newNode;
}

void depthFirstSearch(struct Graph* graph, int vertex, int visited[]) {
visited[vertex] = 1;
printf("%d ", vertex);

struct Node* current = graph->adjList[vertex];
while (current != NULL) {
    if (!visited[current->data]) {
        depthFirstSearch(graph, current->data, visited);
    }
    current = current->next;
}
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

printf("Enter the starting vertex for DFS: ");
int startVertex;
scanf("%d", &startVertex);

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

printf("Depth-First Search Traversal starting from vertex %d: ", startVertex);
depthFirstSearch(graph, startVertex, visited);
printf("\n");

return 0;
}

<pre><h2>OUTPUT</h2></pre>
    
Enter the number of vertices: 5
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 4
Enter edge 3 (source destination): 1 3
Enter edge 4 (source destination): 1 2
Enter the starting vertex for DFS: 0
Depth-First Search Traversal starting from vertex 0: 0 1 3 2 4 
</pre>

<!-- Question 5 -->
<h2 id="g-q5">Question 5: Breadth First Search on Adjacency Matrix</h2>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void breadthFirstSearch(int startVertex, int V, int adjacencyMatrix[V][V], int visited[]) {
int queue[V];
int front = -1, rear = -1;

printf("Breadth-First Search Traversal starting from vertex %d: ", startVertex);

visited[startVertex] = 1;
queue[++rear] = startVertex;

while (front != rear) {
    int currentVertex = queue[++front];
    printf("%d ", currentVertex);

    for (int i = 0; i &lt; V; i++) {
        if (adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
            visited[i] = 1;
            queue[++rear] = i;
        }
    }
}

printf("\n");
}

int main() {
int V;

printf("Enter the number of vertices: ");
scanf("%d", &V);

int adjacencyMatrix[V][V];

printf("Enter the adjacency matrix (%d x %d):\n", V, V);
for (int i = 0; i &lt; V; i++) {
    for (int j = 0; j &lt; V; j++) {
        scanf("%d", &adjacencyMatrix[i][j]);
    }
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

int startVertex;
printf("Enter the starting vertex for BFS: ");
scanf("%d", &startVertex);

breadthFirstSearch(startVertex, V, adjacencyMatrix, visited);

return 0;
}

<pre><h2>OUTPUT</h2></pre>  

Enter the number of vertices: 5
Enter the adjacency matrix (5 x 5):
0 1 0 0 1
1 0 1 1 0
0 1 0 0 0
0 1 0 0 0
1 0 0 0 0
Enter the starting vertex for BFS: 0
Breadth-First Search Traversal starting from vertex 0: 0 1 4 2 3 
</pre>
<!-- Question 6 -->
<h2 id="g-q6">Question 6: Breadth First Search on Adjacency List</h2>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode->data = data;
newNode->next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph->V = V;
graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph->adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph->adjList[src];
graph->adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph->adjList[dest];
graph->adjList[dest] = newNode;
}

void breadthFirstSearch(struct Graph* graph, int startVertex, int visited[]) {
int queue[graph->V];
int front = -1, rear = -1;

printf("Breadth-First Search Traversal starting from vertex %d: ", startVertex);

visited[startVertex] = 1;
queue[++rear] = startVertex;

while (front != rear) {
    int currentVertex = queue[++front];
    printf("%d ", currentVertex);

    struct Node* current = graph->adjList[currentVertex];
    while (current != NULL) {
        if (!visited[current->data]) {
            visited[current->data] = 1;
            queue[++rear] = current->data;
        }
        current = current-&gt;next;
    }
}

printf("\n");
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

int startVertex;
printf("Enter the starting vertex for BFS: ");
scanf("%d", &startVertex);

breadthFirstSearch(graph, startVertex, visited);

return 0;
}

<pre><h2>OUTPUT</h2></pre>

Enter the number of vertices: 5
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 4
Enter edge 3 (source destination): 1 2
Enter edge 4 (source destination): 1 3
Enter the starting vertex for BFS: 0
Breadth-First Search Traversal starting from vertex 0: 0 1 4 2 3 
</pre>
            </div>
        </section>
    </div>
    <!-- Back to Top Button -->
    <button class="back-to-top">Back to Top</button>
    <script>
        // Show the back-to-top button when user scrolls down
        window.onscroll = function () {
            var backToTopBtn = document.querySelector('.back-to-top');
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = 'block';
            } else {
                backToTopBtn.style.display = 'none';
            }
        };

        // Scroll back to top when button is clicked
        document.querySelector('.back-to-top').onclick = function () {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };
    </script>
</body>
</html>
